#!/usr/bin/env python
import math as m
import numpy as np
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.integrate import quad
import simplejson
import urllib
import time
import buildClothoid
import random

ELEVATION_BASE_URL = 'https://maps.googleapis.com/maps/api/elevation/json'
CHART_BASE_URL = 'http://chart.apis.google.com/chart'



def add(vector_1, vector_2):
    return [vector_1[i] + vector_2[i] for i in range(len(vector_1))]

def subtract(vector_1, vector_2):
    return [vector_1[i] - vector_2[i] for i in range(len(vector_1))]

def scale(scalar, vector):
    return [scalar * vector[i] for i in range(len(vector))]

def norm(vector): 
    return sum([m.pow(vector[i],2) for i in range(len(vector))])

def catenate(list_of_lists):
    result = []
    for i in range(len(list_of_lists)):
        result = result + list_of_lists[i]
    return result

#_____________BEGINNING OF ELEVATION FUNCTIONS______________

def getElevation(coordinates):
    args = {
        'locations': '|'.join([str(coordinate[0]) + ',' + str(coordinate[1]) for coordinate in coordinates])
    }

    url = ELEVATION_BASE_URL + '?' + urllib.urlencode(args)
    response = simplejson.load(urllib.urlopen(url))

    # Create a dictionary for each results[] object
    elevationArray = []

    for resultset in response['results']:
        elevationArray.append(resultset['elevation'])

    return elevationArray

def getHeights(cell_center, primitiveVector):
    N = int(np.norm(primitiveVector) / pylon_spacing)
    pylon_locations = [np.add(cell_center, k * pylon_spacing * primitiveVector / np.norm(primitiveVector)) for k in range(-N / 2, N / 2)]
    pylon_locations_array = [[(location[1], location[0]) for location in pylon_locations]]
    return getElevation(pylon_locations_array)


#returns indices of the sorted list.
def getIndices(List): 
    Indices_backwards = sorted(range(len(List)), key = lambda k: List[k])
    return [Indices_backwards[-i] for i in range(1, len(Indices_backwards))] + [Indices_backwards[0]]

#def curvature(location1, location2, List):
#    curvatures = buildClothoid.buildClothoid(location1 * pylon_spacing, List[location1], 0, location2 * pylon_spacing, List[location2], 0)[0:1]
#    return max(curvatures)

def length(location1, location2, List):
    return buildClothoid.buildClothoid(location1 * pylon_spacing, List[location1], 0, location2 * pylon_spacing, List[location2], 0)[2]

def produceInterp_indices(List, sortIndices):
    N = len(List)
    truncated_List = [List[i] for i in range(1,N - 1)]
    truncated_sortIndices = getIndices(truncated_List)
    j= [0, truncated_sortIndices[0] + 1, N - 1]
    i = 1
    while length(j[i - 1], j[i], List) < (j[i] - j[i - 1]) * pylon_spacing + m.fabs(List[j[i]] - List[j[i - 1]]) and length(j[i], j[i + 1], List) < (j[i + 1] - j[i]) * pylon_spacing + m.fabs(List[j[i + 1]] - List[j[i]]) and j != range(len(List)):
        #print "trying a new point, because the curvatures for the previous choice are:"
        #print curvature(j[i - 1], j[i], List)
        #print curvature(j[i],j[i + 1], List)
        k = 0
        #print "This is the index of the new point:"
        #print truncated_sortIndices[1] + 1
        #print "we're trying to fit it in j:"
        #print j
        while truncated_sortIndices[1] + 1 > j[k]:
            k += 1
        i = k
        j.insert(k, truncated_sortIndices[1] + 1)
        #print "Did we insert the index in the right place?:"
        #print j        
        #print "okay, done! - just one more thing: is sInd missing its first element?:"
        #print truncated_sortIndices
        del truncated_sortIndices[0]
        #print truncated_sortIndices
    #print "we did not continue, because the curvatures for the previous choice are:"
    #print curvature(j[i - 1], j[i], List)
    #print curvature(j[i],j[i + 1], List)
    #print "or it could just be because we got 'em all:"
    return j


def visualize(j, List, pylon_spacing):
    N = len(j)
    data = [buildClothoid.buildClothoid(j[i] * pylon_spacing, List[j[i]], 0, j[i+1] * pylon_spacing, List[j[i+1]], 0) for i in range(N-1)]
    kappas = [elt[0] for elt in data]
    kappaps = [elt[1] for elt in data]
    Ls = [elt[2] for elt in data]
    x0s = [n * pylon_spacing for n in range(len(List))]
    xvals = catenate([[x0s[j[i]] + s * buildClothoid.evalXY(kappaps[i] * m.pow(s,2), kappas[i] * s, 0, 1)[0][0] for s in np.linspace(0, Ls[i] , 100)] for i in range(len(j)-1)])
    yvals = catenate([[List[j[i]] + s * buildClothoid.evalXY(kappaps[i] * m.pow(s,2), kappas[i] * s, 0, 1)[1][0] for s in np.linspace(0, Ls[i] , 100)] for i in range(len(j)-1)])
    yvals_plot = [0] * len(List)
    for l in range(len(j)-1):
        for n in range(j[l], j[l + 1]):
            yvals_plot[n] = yvals[100 * l + int((n - j[l]) * 100 / (j[l + 1] - j[l]))]
    fig = plt.figure()
    plt.plot(xvals, yvals, label = "elevation of tube")
    plt.plot(np.arange(0, pylon_spacing * len(List), pylon_spacing), List, label = "elevation of terrain")
    plt.vlines(np.arange(0, pylon_spacing * len(List), pylon_spacing), List, yvals_plot)
    plt.legend(bbox_to_anchor=(.85, 1.), loc=2, borderaxespad=-3.)
    fig.suptitle('Result of Pylon Placement')
    plt.xlabel('distance (m)')
    plt.ylabel('elevation (m above sealevel)')
    return plt.show()


pylon_spacing = 100
List = [11]+[random.randint(0,10) for r in range(12)]+[11]
sortIndices = getIndices(List)
j = produceInterp_indices(List, sortIndices)
print j
print visualize(j, List, pylon_spacing)

