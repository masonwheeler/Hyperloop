#!/usr/bin/env python
import math as m
import numpy as np
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.integrate import quad
import simplejson
import urllib
import time
import buildClothoid

ELEVATION_BASE_URL = 'https://maps.googleapis.com/maps/api/elevation/json'
CHART_BASE_URL = 'http://chart.apis.google.com/chart'



def add(vector_1, vector_2):
    return [vector_1[i] + vector_2[i] for i in range(len(vector_1))]

def subtract(vector_1, vector_2):
    return [vector_1[i] - vector_2[i] for i in range(len(vector_1))]

def scale(scalar, vector):
    return [scalar * vector[i] for i in range(len(vector))]

def norm(vector): 
    return sum([m.pow(vector[i],2) for i in range(len(vector))])


#_____________BEGINNING OF ELEVATION FUNCTIONS______________

def getElevation(coordinates):
    args = {
        'locations': '|'.join([str(coordinate[0]) + ',' + str(coordinate[1]) for coordinate in coordinates])
    }

    url = ELEVATION_BASE_URL + '?' + urllib.urlencode(args)
    response = simplejson.load(urllib.urlopen(url))

    # Create a dictionary for each results[] object
    elevationArray = []

    for resultset in response['results']:
        elevationArray.append(resultset['elevation'])

    return elevationArray

def getHeights(cell_center, primitiveVector):
    N = int(np.norm(primitiveVector) / pylon_spacing)
    pylon_locations = [np.add(cell_center, k * pylon_spacing * primitiveVector / np.norm(primitiveVector)) for k in range(-N / 2, N / 2)]
    pylon_locations_array = [[(location[1], location[0]) for location in pylon_locations]]
    return getElevation(pylon_locations_array)


#returns indices of the sorted list.
def getIndices(List): 
    Indices_backwards = sorted(range(len(List)), key = lambda k: List[k])
    return [Indices_backwards[-i] for i in range(1, len(Indices_backwards))] + [Indices_backwards[0]]

def curvature(location1, location2, List):
    curvatures = buildClothoid.buildClothoid(location1 * pylon_spacing, List[location1], 0, location2 * pylon_spacing, List[location2], 0)[0:1]
    return max(curvatures)

def produceInterp_indices(List, sortIndices):
    N = len(List)
    truncated_List = [List[i] for i in range(1,N - 1)]
    truncated_sortIndices = getIndices(truncated_List)
    Interp_indices= [0, truncated_sortIndices[0] + 1, N - 1]
    i = 1
    while m.fabs(curvature(Interp_indices[i - 1], Interp_indices[i], List)) < k_tol and m.fabs(curvature(Interp_indices[i],Interp_indices[i + 1], List)) < k_tol and Interp_indices != range(len(List)):
        #print "trying a new point, because the curvatures for the previous choice are:"
        #print curvature(Interp_indices[i - 1], Interp_indices[i], List)
        #print curvature(Interp_indices[i],Interp_indices[i + 1], List)
        k = 0
        #print "This is the index of the new point:"
        #print truncated_sortIndices[1] + 1
        #print "we're trying to fit it in Interp_indices:"
        #print Interp_indices
        while truncated_sortIndices[1] + 1 > Interp_indices[k]:
            k += 1
        i = k
        Interp_indices.insert(k, truncated_sortIndices[1] + 1)
        #print "Did we insert the index in the right place?:"
        #print Interp_indices        
        #print "okay, done! - just one more thing: is sInd missing its first element?:"
        #print truncated_sortIndices
        del truncated_sortIndices[0]
        #print truncated_sortIndices
    #print "we did not continue, because the curvatures for the previous choice are:"
    #print curvature(Interp_indices[i - 1], Interp_indices[i], List)
    #print curvature(Interp_indices[i],Interp_indices[i + 1], List)
    #print "or it could just be because we got 'em all:"
    return Interp_indices

pylon_spacing = 1
List = [12,1,2,-1,2,5,8,7,8,5,2,-1,12]
sortIndices = getIndices(List)
k_tol = 1
print produceInterp_indices(List, sortIndices)



#kappa, kappa_prime, L = buildClothoid(3 * pylon_spacing, List[3], 0, 6 * pylon_spacing, List[6], 0)

#xvals = [3 + s * evalXY(kappa_prime * m.pow(s,2), kappa * s, 0, 1)[0][0] for s in np.linspace(0, L , 100)]
#yvals = [List[3] + s * evalXY(kappa_prime * m.pow(s,2), kappa * s, 0, 1)[1][0] for s in np.linspace(0, L , 100)]
#fig = plt.figure()
#plt.plot(xvals, yvals, range(0,len(List)), List)
#fig.suptitle('Clothoid, tht0 = 0, tht1 = 0.')
#plt.xlabel('x')
#plt.ylabel('y')


plt.show()



