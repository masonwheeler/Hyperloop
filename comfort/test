import math
import numpy as np
import time
import scipy
import scipy.interpolate
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


def interpolate_spline(x, y):
	N = len(x) - 1
	h = [x[i+1] - x[i] for i in range(N)]
	s = [(y[i+1] - y[i]) / h[i] for i in range(N)]
	b = [0]*(N+1)
	b[0] = 6 * s[0]
	b[-1] = -6 * s[-1]
	for i in range(1,N):
		b[i] = 6 * (s[i] - s[i-1])
	A = [([0]*(N+1)) for i in range(N+1)]
	A[0][0] = 2 * h[0]
	A[-1][-1] = 2 * h[-1]
	A[0][1] = h[0]
	A[-1][-2] = h[-1]
	for i in range(1, N):
		A[i][i] = 2 * (h[i-1] + h[i])
		A[i][i-1] = h[i-1]
		A[i][i+1] = h[i]
	A = np.array(A)
	b = np.array(b)
	m = np.linalg.solve(A,b).tolist()
	a = [([0] * 4) for i in range(N)]
	for i in range(N):
		a[i][0] = y[i]
		a[i][1] = s[i] - h[i] * m[i]/2 - h[i] * (m[i+1] - m[i])/6
		a[i][2] = m[i]/2
		a[i][3] =  (m[i+1] - m[i])/(6 * h[i])
	return [a, x] 


def eval_polynomial(x, a, x_i):
	condlist = [(x_i[j] < x)*(x<x_i[j+1]) for j in range(len(x_i)-2)]
	def f(k):
		return lambda x: sum([a[k][j] * (x - x_i[k])**j for j in range(4)])
	funclist = [f(k) for k in range(len(a))]
	return np.piecewise(x, condlist, funclist)


x = [1.0,4.0,5.0,7.0,10.0]
y = [0.0,1.0,3.0,2.0,6.0]

a, x_i = interpolate_spline(x,y)

x_plot = np.linspace(1.1,10.0,100)
y_plot = eval_polynomial(x_plot, a, x_i)
print y_plot
fig = plt.figure()

plt.plot(x,y, x_plot, y_plot)
plt.show()



